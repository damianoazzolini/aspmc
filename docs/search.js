window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "aspmc", "modulename": "aspmc", "qualname": "", "type": "module", "doc": "<p>An efficient algebraic answer set counter.</p>\n\n<p>This module provides access to multiple useful submodules for counting the answer sets of an Answer Set Program.</p>\n\n<h6 id=\"compilation\">Compilation</h6>\n\n<blockquote>\n  <p>The module aspmc.compile provides an extended cnf class, which also stores:</p>\n  \n  <ul>\n  <li>weights of literals</li>\n  <li>the semiring(s) over which the weights are</li>\n  <li>information about which variables are \"quantified\" over which semiring</li>\n  <li>how to convert the value of one semiring value into another one</li>\n  </ul>\n  \n  <p>Most prominently it has a compile method, which uses the information of the extended cnf\n  to evaluate the algebraic model counting problem described in it.  </p>\n</blockquote>\n\n<h6 id=\"graphs\">Graphs</h6>\n\n<blockquote>\n  <p>The module aspmc.graph contains all the graph related classes:</p>\n  \n  <ul>\n  <li>a hypergraph class,</li>\n  <li>a binary tree class,</li>\n  <li>a tree decomposition class.  </li>\n  </ul>\n  \n  <p>Most prominently it allows the computation of a tree decomposition given a graph or hypergraph.</p>\n</blockquote>\n\n<h6 id=\"parsing\">Parsing</h6>\n\n<blockquote>\n  <p>The module aspmc.parsing contains different parsers for different programs:</p>\n  \n  <ul>\n  <li>clingo parser for ASP programs,</li>\n  <li>parser for algebraic problog programs,</li>\n  <li>meu parser for maximum expected utility programs.  </li>\n  </ul>\n  \n  <p>Each returns a set of rules, queries in the format defined in the respective semantics modules.</p>\n</blockquote>\n\n<h6 id=\"programs\">Programs</h6>\n\n<blockquote>\n  <p>The module aspmc.programs contains different program modules:</p>\n  \n  <ul>\n  <li>program: The base class, without extras,</li>\n  <li>algebraicprogram: Adds weights for atoms,</li>\n  <li>twoalgebraicprogram: Adds weights over two different semirings for different atoms,</li>\n  <li>smprogram: is a special twoalgebraicprogram that computes a normalized weighted answer set count,</li>\n  <li>meuprogram: is a special twoalgebraicprogram that computes the maximum expected utility of a problog program with a set of decisions.  </li>\n  </ul>\n  \n  <p>Most prominently these classes can transform the program into an extended cnf that can be compiled to obtain the algebraic answer set count.</p>\n</blockquote>\n\n<h6 id=\"semirings\">Semirings</h6>\n\n<blockquote>\n  <p>The module aspmc.semirings contains a collection of different semirings:</p>\n  \n  <ul>\n  <li>grad: gradient semiring,</li>\n  <li>maxplus: max tropical semiring,</li>\n  <li>probabilistic: probabilistic semiring,</li>\n  <li>two_nat: crossproduct of the natural number semiring with itself.  </li>\n  </ul>\n  \n  <p>They follow a simple format, thus this library can be easily extended with custom semirings.</p>\n</blockquote>\n\n<h6 id=\"configuration\">Configuration</h6>\n\n<blockquote>\n  <p>The global configuration object can be found in aspmc.config.</p>\n</blockquote>\n\n<h6 id=\"utilities\">Utilities</h6>\n\n<blockquote>\n  <p>The module aspmc.util contains utility functions for working with literals in different formats.</p>\n</blockquote>\n"}, {"fullname": "aspmc.compile", "modulename": "aspmc.compile", "qualname": "", "type": "module", "doc": "<p>Compilation module of aspmc.</p>\n\n<p>This module provides access to an extended cnf class, which can be used to compile and \nevaluate algebraic model counting problems over cnfs using the knowledge compiler in aspmc.config.</p>\n\n<h6 id=\"cnf-class\">CNF class</h6>\n\n<blockquote>\n  <p>The module aspmc.compile.cnf provides an extended cnf class, which also stores:</p>\n  \n  <ul>\n  <li>weights of literals</li>\n  <li>the semiring(s) over which the weights are</li>\n  <li>information about which variables are \"quantified\" over which semiring</li>\n  <li>how to convert the value of one semiring value into another one</li>\n  </ul>\n  \n  <p>Most prominently it has a compile method, which uses the information of the extended cnf\n  to evaluate the algebraic model counting problem described in it.  </p>\n</blockquote>\n\n<h6 id=\"xtrees\">XTrees</h6>\n\n<blockquote>\n  <p>The modules aspmc.compile.dtree and aspmc.compile.vtree contain a class Dtree and Vtree respectively.\n  They can be given to c2d and miniC2D respectively to tell them in which order variables should be decided.\n  Both trees can be generated from treedecompositions to obtain trees that allow for efficient evaluation.</p>\n</blockquote>\n\n<h6 id=\"evaluation\">Evaluation</h6>\n\n<blockquote>\n  <p>The modules aspmc.compile.circuit, aspmc.compile.constrained_ddnnf, aspmc.compile.constrained_sdd contain\n  different circuit classes, each of which have static methods for parsing a tractalble circuit and evaluating an \n  algebraic model counting instance over it in polynomial time in the size of the circuit. The different submodules handle different circuits:</p>\n  \n  <ul>\n  <li>aspmc.compile.circuit handles first level problems, where only one semiring is used.</li>\n  <li>aspmc.compile.constrained_ddnnf handles second level problems, where two semirings are used, over (smooth) ddnnfs.</li>\n  <li>aspmc.compile.constrained_sdd handles second level problems, where two semirings are used, over sdds.</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"separators\">Separators</h6>\n\n<blockquote>\n  <p>The module aspmc.compile.separator contains a clingo extension that computes an optimal model of an ASP program with #optimize statements.</p>\n</blockquote>\n"}, {"fullname": "aspmc.compile.circuit", "modulename": "aspmc.compile.circuit", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.circuit.Node", "modulename": "aspmc.compile.circuit", "qualname": "Node", "type": "class", "doc": "<p>A node class corresponding to nodes in a <code>Circuit</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>type (<code>int</code>):</strong>  Which type the node has. One of <code>Node.AND, Node.OR, Node.NEG, Node.IN</code>.</li>\n<li><strong>name (<code>int</code>):</strong>  Unique identifier of the node.</li>\n<li><strong>children (<code>iterable</code>, optional):</strong>  The children of the node. Defaults to <code>[]</code>.</li>\n<li><strong>ancestors (<code>iterable</code>, optional):</strong>  The ancestors of the node. Defaults to <code>[]</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>type (<code>int</code>):</strong>  Which type the node has. One of <code>Node.AND, Node.OR, Node.NEG, Node.IN</code>.</li>\n<li><strong>name (<code>int</code>):</strong>  Unique identifier of the node. </li>\n<li>If <code>type</code> is <code>Node.NEG</code> or <code>Node.IN</code> this is the name of the (negated) input variable.</li>\n<li><strong>children (<code>iterable</code>):</strong>  The children of the node.</li>\n<li><strong>ancestors (<code>iterable</code>):</strong>  The ancestors of the node.</li>\n</ul>\n"}, {"fullname": "aspmc.compile.circuit.Node.__init__", "modulename": "aspmc.compile.circuit", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "type", "name", "children", "ancestors"], "funcdef": "def"}, {"fullname": "aspmc.compile.circuit.Node.AND", "modulename": "aspmc.compile.circuit", "qualname": "Node.AND", "type": "variable", "doc": "<p>Node type <code>AND</code> with value 0. Means that the children are conjoined.</p>\n"}, {"fullname": "aspmc.compile.circuit.Node.OR", "modulename": "aspmc.compile.circuit", "qualname": "Node.OR", "type": "variable", "doc": "<p>Node type <code>OR</code> with value 1. Means that the children are disjoined.</p>\n"}, {"fullname": "aspmc.compile.circuit.Node.NEG", "modulename": "aspmc.compile.circuit", "qualname": "Node.NEG", "type": "variable", "doc": "<p>Node type <code>NEG</code> with value 2. Means that this is a negative input variable.</p>\n"}, {"fullname": "aspmc.compile.circuit.Node.IN", "modulename": "aspmc.compile.circuit", "qualname": "Node.IN", "type": "variable", "doc": "<p>Node type <code>IN</code> with value 3. Means that this is a positive input variable.</p>\n"}, {"fullname": "aspmc.compile.circuit.Circuit", "modulename": "aspmc.compile.circuit", "qualname": "Circuit", "type": "class", "doc": "<p>A circuit class that can store for example d-DNNFs and SDDs. </p>\n\n<p>Offers methods to perform algebraic model counting on the circuit in linear time in the size of the (smooth) circuit.\nAlso offers the same methods statically to avoid storing the circuit in memory. \nThen the algebraic model counting is performed while reading the circuit.</p>\n\n<p>Supports the d-DNNF format of c2d and miniC2D for constructing circuits.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file that contains the circuit.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>literals (<code>list</code>):</strong>  The literals in the circuit. The node for literal <code>v</code> is in <code>literals[2*(v-1)]</code>, the one for <code>-v</code> is in <code>literals[2*(v-1)+1]</code></li>\n<li><strong>nodes (<code>list</code>):</strong>  All the nodes of the circuit that are not literals.</li>\n</ul>\n"}, {"fullname": "aspmc.compile.circuit.Circuit.__init__", "modulename": "aspmc.compile.circuit", "qualname": "Circuit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "aspmc.compile.circuit.Circuit.non_smooth_wmc", "modulename": "aspmc.compile.circuit", "qualname": "Circuit.non_smooth_wmc", "type": "function", "doc": "<p>Performs weighted model counting over a circuit that is not smooth. Should be avoided since it is quite inefficient.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. \nThe weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The weighted model count.</p>\n</blockquote>\n", "parameters": ["self", "weights"], "funcdef": "def"}, {"fullname": "aspmc.compile.circuit.Circuit.wmc", "modulename": "aspmc.compile.circuit", "qualname": "Circuit.wmc", "type": "function", "doc": "<p>Performs algebraic model counting over a circuit that is smooth.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["self", "weights"], "funcdef": "def"}, {"fullname": "aspmc.compile.circuit.Circuit.parse_wmc", "modulename": "aspmc.compile.circuit", "qualname": "Circuit.parse_wmc", "type": "function", "doc": "<p>Performs algebraic model counting over a circuit that is smooth while parsing it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file that contains the circuit.</li>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n<li><strong>zero (<code>object</code>, optional):</strong>  The neutral element of addition. Defaults to <code>0.0</code>.</li>\n<li><strong>one (<code>object</code>, optional):</strong>  The neutral element of multiplication. Defaults to <code>1.0</code>.</li>\n<li><strong>dtype (<code>type</code>, optional):</strong>  Which type the numpy arrays used to store the weights should have. Defaults to <code>float</code>.</li>\n<li><strong>solver (<code>string</code>, optional):</strong>  Which knowledge compiler this d-DNNF is from. Defaults to <code>c2d</code>.</li>\n<li><strong>vtree (<code>aspmc.compile.vtree.Vtree</code>, optional):</strong>  The underlying vtree if this is a non-smooth SDD. Defaults to <code>None</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["path", "weights", "zero", "one", "dtype", "solver", "vtree"], "funcdef": "def"}, {"fullname": "aspmc.compile.circuit.Circuit.live_parse_wmc", "modulename": "aspmc.compile.circuit", "qualname": "Circuit.live_parse_wmc", "type": "function", "doc": "<p>Performs algebraic model counting over a circuit that is smooth while parsing it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pipe (<code>stream</code>):</strong>  The pipe where the circuit is printed.</li>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n<li><strong>zero (<code>object</code>, optional):</strong>  The neutral element of addition. Defaults to <code>0.0</code>.</li>\n<li><strong>one (<code>object</code>, optional):</strong>  The neutral element of multiplication. Defaults to <code>1.0</code>.</li>\n<li><strong>dtype (<code>type</code>, optional):</strong>  Which type the numpy arrays used to store the weights should have. Defaults to <code>float</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["pipe", "weights", "zero", "one", "dtype"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf", "modulename": "aspmc.compile.cnf", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.cnf.SolvingError", "modulename": "aspmc.compile.cnf", "qualname": "SolvingError", "type": "class", "doc": "<p>raise this when a solver errors</p>\n"}, {"fullname": "aspmc.compile.cnf.CNF", "modulename": "aspmc.compile.cnf", "qualname": "CNF", "type": "class", "doc": "<p>This class is an extended cnf class, which can be used to compile and \nevaluate algebraic model counting problems over cnfs using the knowledge compiler in aspmc.config.</p>\n\n<h6 id=\"the-syntax-of-extended-cnf-files-is-as-follows\">The syntax of extended cnf files is as follows</h6>\n\n<blockquote>\n  <ul>\n  <li><p>format string: one line specifying the number of variables and clauses.</p>\n  \n  <p><code>p cnf &lt;nr_vars&gt; &lt;len(clauses)&gt;</code></p></li>\n  <li><p>clauses: one line for each clause <code>c = [lit_1, lit_2, ..., lit_n]</code>.</p>\n  \n  <p><code>&lt;lit_1&gt; &lt;lit_2&gt; ... &lt;lit_n&gt; 0</code></p></li>\n  <li><p>weights: one line for each weight \"w = np.array([w_1, w_2, ..., w_n])\" of a literal <code>lit</code>.</p>\n  \n  <p><code>c p weight &lt;lit&gt; &lt;w_1&gt;;&lt;w_2&gt;;...;&lt;w_n&gt; 0</code></p></li>\n  <li><p>semirings: one line containing all the names of the semiring modules <code>semirings = [s_1, s_2, ..., s_n]</code>.</p>\n  \n  <p><code>c p semirings &lt;s_1.__name__&gt; &lt;s_2.__name__&gt; ... &lt;s_n.__name__&gt; 0</code></p></li>\n  <li><p>quantified: one line for each list <code>q_i = [v_1, ..., v_n]</code> in quantified. Lowest index quantified variables first.</p>\n  \n  <p><code>c p quantify &lt;v_1&gt; &lt;v_2&gt; ... &lt;v_n&gt; 0</code></p></li>\n  <li><p>tranform: one line containing the transformation function from semiring[1] to semiring[0] in string representation.\n  Must be such that <code>eval(repr(transform))</code> works independently of the imported modules.</p>\n  \n  <p><code>c p transform &lt;repr(transform)&gt; 0</code></p></li>\n  </ul>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>, optional):</strong>  Optional parameter specifying the location of an extended cnf file to load. Defaults to None.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>clauses (list):</strong>  A list of clauses with literals in minisat format.</li>\n<li><strong>nr_vars (int):</strong>  The number of variables that the cnf is specified over.</li>\n<li><strong>weights (dict):</strong>  A dictionary that can contain for each integer from {-nr_vars, ..., -1, 1, ..., nr_vars} a weight over a semiring.\nNote that even if there is only one semiring value it must be encapsulated in a numpy array.</li>\n<li><strong>semirings (list):</strong>  A list of semiring modules that are used in this cnf.\nSee aspmc.semirings for how these modules should look.\nCurrently at most two semirings are supported.</li>\n<li><strong>quantified (list):</strong>  A list of lists of variables (integers) specifying, which variables are \"quantified\" over which semirings.\nMust have the same length as <code>semirings</code>.\nThe variables in quantified[i] are over semirings[i].\nThe variables in quantified[i] are quantified before the ones in quantified[i+i].</li>\n<li><strong>transform (string):</strong>  A string representation of a python function that takes a values from semiring[i] and returns a value <code>x</code> that can be given to \n<code>semirings[i-1].from_value(x)</code> to obtain a value in semirings[i-1].</li>\n</ul>\n"}, {"fullname": "aspmc.compile.cnf.CNF.__init__", "modulename": "aspmc.compile.cnf", "qualname": "CNF.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.write_kc_cnf", "modulename": "aspmc.compile.cnf", "qualname": "CNF.write_kc_cnf", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "out_file"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.write_maxsat_cnf", "modulename": "aspmc.compile.cnf", "qualname": "CNF.write_maxsat_cnf", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "out_file"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.get_defined", "modulename": "aspmc.compile.cnf", "qualname": "CNF.get_defined", "type": "function", "doc": "<p>Figures out the subset of variables of the cnf that are defined by <code>P</code> w.r.t. the cnf.\nCalls a C++ binary for performance reasons.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>P (iterable):</strong>  The set of input variables that can be used for definitions.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list: The list of variables that are defined by the inputs <code>P</code> w.r.t. the cnf.</p>\n</blockquote>\n", "parameters": ["self", "P", "timeout"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.is_sat", "modulename": "aspmc.compile.cnf", "qualname": "CNF.is_sat", "type": "function", "doc": "<p>Calls <code>minisat</code> to check if the cnf is satisfiable.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool: <code>True</code> if the cnf is satisfiable, <code>False</code> otherwise.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.to_file", "modulename": "aspmc.compile.cnf", "qualname": "CNF.to_file", "type": "function", "doc": "<p>Write the cnf to the file with the name <code>path</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (string):</strong>  The path of the file the cnf should be written to.</li>\n<li><strong>extras (bool, optional):</strong>  Whether the extra information like weights should be written. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "path", "extras"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.to_stream", "modulename": "aspmc.compile.cnf", "qualname": "CNF.to_stream", "type": "function", "doc": "<p>Write the cnf to the stream <code>stream</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stream (stream):</strong>  The stream the cnf should be written to. Must accept binary encoding.</li>\n<li><strong>extras (bool, optional):</strong>  Whether the extra information like weights should be written. Defaults to False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "stream", "extras"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.primal_graph", "modulename": "aspmc.compile.cnf", "qualname": "CNF.primal_graph", "type": "function", "doc": "<p>Construct the an <code>nx.Graph</code> that corresponds to the primal graph of the cnf.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>nx.Graph: The primal graph of the cnf.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.primal_hypergraph", "modulename": "aspmc.compile.cnf", "qualname": "CNF.primal_hypergraph", "type": "function", "doc": "<p>Construct the an <code>aspmc.graph.Hypergraph</code> that corresponds to the primal hypergraph of the cnf.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>aspmc.graph.Hypergraph: The primal hypergraph of the cnf.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.get_weights", "modulename": "aspmc.compile.cnf", "qualname": "CNF.get_weights", "type": "function", "doc": "<p>Get some relevant information about the weights of the cnf in a convenient format.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(list, object, object, type): </p>\n  \n  <p>The weights of the literals. <code>weights[2*(i-1)]</code> is the weight of <code>i</code> and <code>weights[2*(i-1) + 1]</code> is the weight of <code>-i</code>.</p>\n  \n  <p>The zero of the (outermost) AMC instance.</p>\n  \n  <p>The one of the (outermost) AMC instance.</p>\n  \n  <p>The type of the weights that should be used for numpy arrays.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.remove_trivial_clauses", "modulename": "aspmc.compile.cnf", "qualname": "CNF.remove_trivial_clauses", "type": "function", "doc": "<p>Removes all the trivial clauses from the cnf. Trivial clauses are those clauses that contain both <code>v</code> and <code>-v</code> for some variables <code>v</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.evaluate_trivial", "modulename": "aspmc.compile.cnf", "qualname": "CNF.evaluate_trivial", "type": "function", "doc": "<p>Checks if this is a trivial instance and if so returns its value. Before the check all the trivial clauses are removed.</p>\n\n<h6 id=\"an-instance-is-trivial-if-one-of-the-following-is-true\">An instance is trivial if one of the following is true</h6>\n\n<blockquote>\n  <ul>\n  <li>It contains no clauses.</li>\n  <li>It is unsatisfiable.</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>object: The value of the AMC instance if it is trivial and <code>None</code> otherwise.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.compile_single", "modulename": "aspmc.compile.cnf", "qualname": "CNF.compile_single", "type": "function", "doc": "<p>Compiles an AMC instance over a single semiring and performs the algebraic model counting over the compiled circuit.</p>\n\n<p>Currently supports c2d and miniC2D as knowledge compilers. \nGenerates a D/Vtree from a tree decomposition of the cnf.\nHow the tree decomposition is generated and which knowledge compiler is used is configured in aspmc.config.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>object: The value of the AMC instance.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.compile_two", "modulename": "aspmc.compile.cnf", "qualname": "CNF.compile_two", "type": "function", "doc": "<p>Compiles a 2AMC instance over a two semirings into an X/D-constrained circuit and performs the algebraic model counting over the compiled circuit.</p>\n\n<p>Currently supports c2d and miniC2D as knowledge compilers. \nGenerates an X/D-constrained D/Vtree by using the function in aspmc.compile.constrained_compile.\nHow the tree decompositions are generated and which knowledge compiler is used is configured in aspmc.config.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>object: The value of the 2AMC instance.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.get_non_contributing_vars", "modulename": "aspmc.compile.cnf", "qualname": "CNF.get_non_contributing_vars", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.get_contributing_vars", "modulename": "aspmc.compile.cnf", "qualname": "CNF.get_contributing_vars", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.preprocessing_idempotent", "modulename": "aspmc.compile.cnf", "qualname": "CNF.preprocessing_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.preprocessing_general", "modulename": "aspmc.compile.cnf", "qualname": "CNF.preprocessing_general", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.preprocessing", "modulename": "aspmc.compile.cnf", "qualname": "CNF.preprocessing", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.compile", "modulename": "aspmc.compile.cnf", "qualname": "CNF.compile", "type": "function", "doc": "<p>Compiles an AMC instance and performs the algebraic model counting over the compiled circuit.</p>\n\n<p>Calls <code>compile_single</code> or <code>compile_two</code>.\nHow the tree decompositions are generated and which knowledge compiler is used is configured in aspmc.config.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>object: The value of the AMC instance.</p>\n</blockquote>\n", "parameters": ["self", "preprocessing"], "funcdef": "def"}, {"fullname": "aspmc.compile.cnf.CNF.solve_maxsat", "modulename": "aspmc.compile.cnf", "qualname": "CNF.solve_maxsat", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile", "modulename": "aspmc.compile.constrained_compile", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.constrained_compile.separator_encoding_asp", "modulename": "aspmc.compile.constrained_compile", "qualname": "separator_encoding_asp", "type": "function", "doc": "<p></p>\n", "parameters": ["graph", "P", "D", "R"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile.compute_separator", "modulename": "aspmc.compile.constrained_compile", "qualname": "compute_separator", "type": "function", "doc": "<p></p>\n", "parameters": ["graph", "P", "D", "R"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile.TD_to_tree", "modulename": "aspmc.compile.constrained_compile", "qualname": "TD_to_tree", "type": "function", "doc": "<p></p>\n", "parameters": ["cnf", "td", "done", "tree_type"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile.from_order", "modulename": "aspmc.compile.constrained_compile", "qualname": "from_order", "type": "function", "doc": "<p></p>\n", "parameters": ["cnf", "order", "done", "tree_type"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile.tree_from_cnf", "modulename": "aspmc.compile.constrained_compile", "qualname": "tree_from_cnf", "type": "function", "doc": "<p>Constructs an X/D-constrained Vtree or Dtree for the given cnf.</p>\n\n<p>Does this by: </p>\n\n<ul>\n<li>getting the atoms <code>X</code> as <code>cnf.quanfied[0]</code>. So the atoms that are quantified over the first semiring.</li>\n<li>getting the atoms <code>D</code> that are defined by <code>X</code> w.r.t. the cnf.</li>\n<li>getting a separator <code>S</code> between the atoms in <code>X</code> and the ones neither in <code>X</code> nor <code>D</code> using atoms from <code>X</code> or <code>D</code>.</li>\n<li>the constructed X/D-constrained D/Vtree then ensures that all the atoms in <code>S</code> are decided first,\nmeaning that all the atoms in <code>X</code> can be decided before/independently of the atoms that are not in <code>X</code> or <code>D</code>.</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cnf (<code>aspmc.compile.cnf.CNF</code>):</strong>  The extended cnf for which a tree should be constructed. Must have exactly two semirings.</li>\n<li><strong>tree_type (<code>type</code>, optional):</strong>  The type of tree to construct. \nMust be one of <code>aspmc.compile.dtree.Dtree</code> and <code>aspmc.compile.vtree.Vtree</code>.\nDefaults to <code>aspmc.compile.dtree.Dtree</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(iterable, aspmc.graph.bintree.bintree): </p>\n  \n  <p>The separator <code>S</code> that was computed.</p>\n  \n  <p>The root of the D/Vtree that was constructed.</p>\n</blockquote>\n", "parameters": ["cnf", "tree_type"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_compile.construct_tree", "modulename": "aspmc.compile.constrained_compile", "qualname": "construct_tree", "type": "function", "doc": "<p></p>\n", "parameters": ["cnf", "graph", "P", "D", "R", "tree_type"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_ddnnf", "modulename": "aspmc.compile.constrained_ddnnf", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.constrained_ddnnf.ConstrainedDDNNF", "modulename": "aspmc.compile.constrained_ddnnf", "qualname": "ConstrainedDDNNF", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.constrained_ddnnf.ConstrainedDDNNF.__init__", "modulename": "aspmc.compile.constrained_ddnnf", "qualname": "ConstrainedDDNNF.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_ddnnf.ConstrainedDDNNF.parse_wmc", "modulename": "aspmc.compile.constrained_ddnnf", "qualname": "ConstrainedDDNNF.parse_wmc", "type": "function", "doc": "<p>Performs (two) algebraic model counting over an X/D-constrained circuit that is smooth while parsing it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file that contains the circuit.</li>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n<li><strong>P (<code>iterable</code>):</strong>  The set of variables that are quantified over the first semiring.</li>\n<li><strong>first_semiring (<code>module</code>):</strong>  The module of the first semiring.</li>\n<li><strong>second_semiring (<code>module</code>):</strong>  The module of the second semiring.</li>\n<li><p><strong>transform (<code>string</code>):</strong>  The transformation function used to transform a value from the second semiring into a value from the first semiring.\nWill be used as</p>\n\n<pre><code>   f_transform = eval(transform)\n   transform = lambda x : first_semiring.from_value(f_transform(x))\n</code></pre></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["path", "weights", "P", "first_semiring", "second_semiring", "transform"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd", "modulename": "aspmc.compile.constrained_sdd", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.constrained_sdd.Node", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node", "type": "class", "doc": "<p>A node class corresponding to nodes in a <code>ConstrainedSDD</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>type (<code>int</code>):</strong>  Which type the node has. One of <code>Node.AND, Node.OR, Node.NEG, Node.IN</code>.</li>\n<li><strong>name (<code>int</code>):</strong>  Unique identifier of the node.</li>\n<li><strong>children (<code>iterable</code>, optional):</strong>  The children of the node. Defaults to <code>[]</code>.</li>\n<li><strong>ancestors (<code>iterable</code>, optional):</strong>  The ancestors of the node. Defaults to <code>[]</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>type (<code>int</code>):</strong>  Which type the node has. One of <code>Node.AND, Node.OR, Node.NEG, Node.IN</code>.</li>\n<li><strong>name (<code>int</code>):</strong>  Unique identifier of the node. </li>\n<li>If <code>type</code> is <code>Node.NEG</code> or <code>Node.IN</code> this is the name of the (negated) input variable.</li>\n<li><strong>children (<code>iterable</code>):</strong>  The children of the node.</li>\n<li><strong>ancestors (<code>iterable</code>):</strong>  The ancestors of the node. </li>\n<li><strong>vtree_node (<code>int</code>):</strong>  The lowest vtree node that this node respects.</li>\n</ul>\n"}, {"fullname": "aspmc.compile.constrained_sdd.Node.__init__", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "type", "name", "children", "ancestors"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.Node.AND", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node.AND", "type": "variable", "doc": "<p>Node type <code>AND</code> with value 0. Means that the children are conjoined.</p>\n"}, {"fullname": "aspmc.compile.constrained_sdd.Node.OR", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node.OR", "type": "variable", "doc": "<p>Node type <code>OR</code> with value 1. Means that the children are disjoined.</p>\n"}, {"fullname": "aspmc.compile.constrained_sdd.Node.NEG", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node.NEG", "type": "variable", "doc": "<p>Node type <code>NEG</code> with value 2. Means that this is a negative input variable.</p>\n"}, {"fullname": "aspmc.compile.constrained_sdd.Node.IN", "modulename": "aspmc.compile.constrained_sdd", "qualname": "Node.IN", "type": "variable", "doc": "<p>Node type <code>IN</code> with value 3. Means that this is a positive input variable.</p>\n"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD", "type": "class", "doc": "<p>A circuit class that can store SDDs. </p>\n\n<p>Offers methods to perform algebraic model counting on the circuit in linear time in the size of the (smooth) circuit.\nAlso offers the same methods statically to avoid storing the circuit in memory. \nThen the algebraic model counting is performed while reading the circuit.</p>\n\n<p>Supports the d-DNNF format of c2d and miniC2D for constructing circuits.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file that contains the circuit.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>literals (<code>list</code>):</strong>  The literals in the circuit. The node for literal <code>v</code> is in <code>literals[2*(v-1)]</code>, the one for <code>-v</code> is in <code>literals[2*(v-1)+1]</code></li>\n<li><strong>nodes (<code>list</code>):</strong>  All the nodes of the circuit that are not literals.</li>\n</ul>\n"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.__init__", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "path", "v3"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.set_vtree", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.set_vtree", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "v3"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.get_vtree_node", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.get_vtree_node", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.separator_node", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.separator_node", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "P"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.wmc", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.wmc", "type": "function", "doc": "<p>Performs (two) algebraic model counting over the X/D-constrained SDD.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n<li><strong>P (<code>iterable</code>):</strong>  The set of variables that are quantified over the first semiring.</li>\n<li><strong>first_semiring (<code>module</code>):</strong>  The module of the first semiring.</li>\n<li><strong>second_semiring (<code>module</code>):</strong>  The module of the second semiring.</li>\n<li><p><strong>transform (<code>string</code>):</strong>  The transformation function used to transform a value from the second semiring into a value from the first semiring.\nWill be used as</p>\n\n<pre><code>   f_transform = eval(transform)\n   transform = lambda x : first_semiring.from_value(f_transform(x))\n</code></pre></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["self", "weights", "P", "first_semiring", "second_semiring", "transform"], "funcdef": "def"}, {"fullname": "aspmc.compile.constrained_sdd.ConstrainedSDD.parse_wmc", "modulename": "aspmc.compile.constrained_sdd", "qualname": "ConstrainedSDD.parse_wmc", "type": "function", "doc": "<p>Performs (two) algebraic model counting over an X/D-constrained SDD while parsing it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file that contains the SDD.</li>\n<li><strong>weights (<code>string</code>):</strong>  The weights of the literals. The weight for literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></li>\n<li><strong>P (<code>iterable</code>):</strong>  The set of variables that are quantified over the first semiring.</li>\n<li><strong>first_semiring (<code>module</code>):</strong>  The module of the first semiring.</li>\n<li><strong>second_semiring (<code>module</code>):</strong>  The module of the second semiring.</li>\n<li><p><strong>transform (<code>string</code>):</strong>  The transformation function used to transform a value from the second semiring into a value from the first semiring.\nWill be used as</p>\n\n<pre><code>   f_transform = eval(transform)\n   transform = lambda x : first_semiring.from_value(f_transform(x))\n</code></pre></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(<code>object</code>): The algebraic model count.</p>\n</blockquote>\n", "parameters": ["self", "path", "weights", "P", "first_semiring", "second_semiring", "transform"], "funcdef": "def"}, {"fullname": "aspmc.compile.dtree", "modulename": "aspmc.compile.dtree", "qualname": "", "type": "module", "doc": "<p>Dtree module providing methods to construct, visualize and generally work with dtrees.</p>\n"}, {"fullname": "aspmc.compile.dtree.Dtree", "modulename": "aspmc.compile.dtree", "qualname": "Dtree", "type": "class", "doc": "<p>A Dtree class that manages dtrees. </p>\n\n<p>These can be used as the input to c2d to (loosely) specify in which order atoms are decided.\nIs a subclass of aspmc.graph.bintree.bintree and therefore has some utility functions, like writing to file, \ncounting the leaves or iterating over the nodes of the tree.</p>\n"}, {"fullname": "aspmc.compile.dtree.from_order", "modulename": "aspmc.compile.dtree", "qualname": "from_order", "type": "function", "doc": "<p>Constructs a (partial) dtree for a cnf from a list of atoms in the specified order.</p>\n\n<p>Modifies the cnf by adding trivial clauses that are used to ensure that the atoms in <code>order</code> are eliminated first.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cnf (<code>aspmc.compile.cnf.CNF</code>):</strong>  The cnf to construct the partial dtree for.</li>\n<li><strong>order (<code>list</code>):</strong>  The list specifying which atoms should be eliminated and the order in which they should be eliminated.</li>\n<li><strong>done (<code>list</code>, optional):</strong>  A list of Booleans specifying which clauses of the cnf are already included in a dtree. </li>\n<li>If given updates the list by setting the value of the added clauses to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Dtree</code>: The (right-linear) dtree that eliminates the atoms in <code>order</code> in the order they are in <code>order</code>.</p>\n</blockquote>\n", "parameters": ["cnf", "order", "done"], "funcdef": "def"}, {"fullname": "aspmc.compile.dtree.TD_to_dtree", "modulename": "aspmc.compile.dtree", "qualname": "TD_to_dtree", "type": "function", "doc": "<p>Constructs a (partial) dtree for a cnf from a tree decomposition.</p>\n\n<p>Build a dtree from the given tree decomposition <code>td</code> adding clauses to the dtree \nin the order in which they are included in the tree decompositions bags. \nBranches, when a tree decomposition bag has multiple children.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cnf (<code>aspmc.compile.cnf.CNF</code>):</strong>  The cnf to construct the partial dtree for.</li>\n<li><strong>td (<code>aspmc.graph.treedecomposition.TreeDecomposition</code>):</strong>  A tree decomposition for a subset of the variables in the cnf.</li>\n<li><strong>done (<code>list</code>, optional):</strong>  A list of Booleans specifying which clauses of the cnf are already included in a dtree. </li>\n<li>If given updates the list by setting the value of the added clauses to True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Dtree</code>: The (partial) dtree corresponding to the tree decomposition.</p>\n</blockquote>\n", "parameters": ["cnf", "td", "done"], "funcdef": "def"}, {"fullname": "aspmc.compile.dtree.TD_dtree", "modulename": "aspmc.compile.dtree", "qualname": "TD_dtree", "type": "function", "doc": "<p>Constructs a dtree for a cnf by generating a tree decomposition and calling <code>TD_to_dtree</code> with it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cnf (<code>aspmc.compile.cnf.CNF</code>):</strong>  The cnf to construct the dtree for.</li>\n<li><strong>solver (<code>string</code>, optional):</strong>  Which solver to use to generate the tree decomposition. Defaults to \"htd\".</li>\n<li><strong>timeout (<code>string</code>, optional):</strong>  The timeout in second to give to the solver. Defaults to \"0.5\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Dtree</code>: The dtree generated by the constructed tree decomposition.</p>\n</blockquote>\n", "parameters": ["cnf", "solver", "timeout"], "funcdef": "def"}, {"fullname": "aspmc.compile.separator", "modulename": "aspmc.compile.separator", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.separator.safe_int", "modulename": "aspmc.compile.separator", "qualname": "safe_int", "type": "function", "doc": "<p></p>\n", "parameters": ["string"], "funcdef": "def"}, {"fullname": "aspmc.compile.separator.ClingoControl", "modulename": "aspmc.compile.separator", "qualname": "ClingoControl", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.compile.separator.ClingoControl.__init__", "modulename": "aspmc.compile.separator", "qualname": "ClingoControl.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prog"], "funcdef": "def"}, {"fullname": "aspmc.compile.separator.ClingoControl.get_separator", "modulename": "aspmc.compile.separator", "qualname": "ClingoControl.get_separator", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "encodingFile", "timeout", "usc", "solve_limit"], "funcdef": "def"}, {"fullname": "aspmc.compile.vtree", "modulename": "aspmc.compile.vtree", "qualname": "", "type": "module", "doc": "<p>Vtree module providing methods to construct, visualize and generally work with vtrees.</p>\n"}, {"fullname": "aspmc.compile.vtree.Vtree", "modulename": "aspmc.compile.vtree", "qualname": "Vtree", "type": "class", "doc": "<p>A Vtree class that manages vtrees. </p>\n\n<p>These can be used as the input to miniC2D to (exactly) specify in which order atoms are decided.\nIs a subclass of aspmc.graph.bintree.bintree and therefore has some utility functions, like writing to file, \ncounting the leaves or iterating over the nodes of the tree.</p>\n"}, {"fullname": "aspmc.compile.vtree.from_order", "modulename": "aspmc.compile.vtree", "qualname": "from_order", "type": "function", "doc": "<p>Constructs a (partial) vtree from a list of atoms in the specified order.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>order (<code>list</code>):</strong>  The list specifying which atoms should be eliminated and the order in which they should be eliminated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Vtree</code>: The (right-linear) vtree that eliminates the atoms in <code>order</code> in the order they are in <code>order</code>.</p>\n</blockquote>\n", "parameters": ["order"], "funcdef": "def"}, {"fullname": "aspmc.compile.vtree.TD_to_vtree", "modulename": "aspmc.compile.vtree", "qualname": "TD_to_vtree", "type": "function", "doc": "<p>Constructs a (partial) vtree from a tree decomposition.</p>\n\n<p>Build a vtree from the given tree decomposition <code>td</code> adding variables to the dtree \nin the order in which they are included in the tree decompositions bags. \nBranches, when a tree decomposition bag has multiple children.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>td (<code>aspmc.graph.treedecomposition.TreeDecomposition</code>):</strong>  A tree decomposition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Vtree</code>: The (partial) vtree corresponding to the tree decomposition.</p>\n</blockquote>\n", "parameters": ["td"], "funcdef": "def"}, {"fullname": "aspmc.compile.vtree.TD_vtree", "modulename": "aspmc.compile.vtree", "qualname": "TD_vtree", "type": "function", "doc": "<p>Constructs a vtree for a cnf by generating a tree decomposition and calling <code>TD_to_vtree</code> with it.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cnf (<code>aspmc.compile.cnf.CNF</code>):</strong>  The cnf to construct the dtree for.</li>\n<li><strong>solver (<code>string</code>, optional):</strong>  Which solver to use to generate the tree decomposition. Defaults to \"htd\".</li>\n<li><strong>timeout (<code>string</code>, optional):</strong>  The timeout in second to give to the solver. Defaults to \"0.5\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Vtree</code>: The vtree generated by the constructed tree decomposition.</p>\n</blockquote>\n", "parameters": ["cnf", "solver", "timeout"], "funcdef": "def"}, {"fullname": "aspmc.config", "modulename": "aspmc.config", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.graph", "modulename": "aspmc.graph", "qualname": "", "type": "module", "doc": "<p>The module aspmc.graph contains all the graph related classes:</p>\n\n<ul>\n<li>a hypergraph class in aspmc.graph.hypergraph, which can be used to generated tree decompositions.</li>\n<li>a binary tree class in aspmc.graph.bintree, which is used for D/Vtrees.</li>\n<li>a tree decomposition class in aspmc.graph.treedecomposition, which can generated tree decompositions from different inputs.\nAlso it offers many different utilities.</li>\n</ul>\n"}, {"fullname": "aspmc.graph.bintree", "modulename": "aspmc.graph.bintree", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.graph.bintree.bintree", "modulename": "aspmc.graph.bintree", "qualname": "bintree", "type": "class", "doc": "<p>A class for binary trees that have values at their leafs.</p>\n\n<p>Is iterable, in post order. Can be drawn, translated to networkx and more.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>val (<code>object</code>):</strong>  The value of the node. Defaults to <code>None</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>left (<code>bintree</code>):</strong>  The left ancestor of this node or <code>None</code> if this node is a leaf.</li>\n<li><strong>right (<code>bintree</code>):</strong>  The right ancestor of this node or <code>None</code> if this node is a leaf. </li>\n<li><strong>val (<code>object</code>):</strong>  The value of this node if it is a leaf or <code>None</code> otherwise. </li>\n<li><strong>idx (<code>int</code>):</strong>  The unique index of this node. Only set after running <code>index()</code> on this or an ancestor node.</li>\n</ul>\n"}, {"fullname": "aspmc.graph.bintree.bintree.__init__", "modulename": "aspmc.graph.bintree", "qualname": "bintree.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "val"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.preorder", "modulename": "aspmc.graph.bintree", "qualname": "bintree.preorder", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.leaf_count", "modulename": "aspmc.graph.bintree", "qualname": "bintree.leaf_count", "type": "function", "doc": "<p>Counts the leafs at or below this node.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>int</code>: The number of leafs.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.index", "modulename": "aspmc.graph.bintree", "qualname": "bintree.index", "type": "function", "doc": "<p>Indexes the nodes in such a way that for leaf nodes <code>idx</code> is equal to <code>val</code>.\nThe rest of the nodes are index in increasing order w.r.t. post order.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.to_networkx", "modulename": "aspmc.graph.bintree", "qualname": "bintree.to_networkx", "type": "function", "doc": "<p>Constructs an equivalent <code>nx.DiGraph</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>nx.Digraph</code>: A digraph representation of this bintree.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.draw", "modulename": "aspmc.graph.bintree", "qualname": "bintree.draw", "type": "function", "doc": "<p>Visualizes this bintree by showing a plot of it. \nMostly useful for debugging.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.bintree.bintree.write", "modulename": "aspmc.graph.bintree", "qualname": "bintree.write", "type": "function", "doc": "<p>Write the string representation of this tree to the file at <code>path</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file to write to.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "path"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph", "modulename": "aspmc.graph.hypergraph", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph", "type": "class", "doc": "<p>A class for Hypergraphs, i.e. graphs that have hyperedges, \nmeaning that they connect an arbitrary subset of vertices with one another.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>nodes (<code>set</code>):</strong>  The nodes/vertices of the hypergraph.</li>\n<li><strong>edges (<code>list</code>):</strong>  The (hyper)edges of the hypergraph.</li>\n</ul>\n"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.__init__", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.add_node", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.add_node", "type": "function", "doc": "<p>Add a single node/vertex to the hypergraph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>node (<code>int</code>):</strong>  The id of the node to add.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.add_nodes_from", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.add_nodes_from", "type": "function", "doc": "<p>Add a nodes/vertices from an iterable to the hypergraph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>nodes (<code>iterable</code>):</strong>  The ids (integers!) of the node to add.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "nodes"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.add_edge", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.add_edge", "type": "function", "doc": "<p>Add a single (hyper)edge to the hypergraph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>edge (<code>iterable</code>):</strong>  The iterable of all the nodes in the edge.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "edge"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.add_edges_from", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.add_edges_from", "type": "function", "doc": "<p>Add a (hyper)edges from an iterable to the hypergraph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>edges (<code>iterable</code>):</strong>  The iterable of iterables all the nodes in the edge.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "edges"], "funcdef": "def"}, {"fullname": "aspmc.graph.hypergraph.Hypergraph.to_graph", "modulename": "aspmc.graph.hypergraph", "qualname": "Hypergraph.to_graph", "type": "function", "doc": "<p>Convert the hypergraph to an <code>nx.Graph</code> by replacing hyperedges with cliques.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>nx.Graph</code>: The graph corresponding to this hypergraph.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition", "modulename": "aspmc.graph.treedecomposition", "qualname": "", "type": "module", "doc": "<p>Tree Decomposition module that introduces a tree decomposition class, a bag class and ways to construct tree decompositions.</p>\n"}, {"fullname": "aspmc.graph.treedecomposition.Bag", "modulename": "aspmc.graph.treedecomposition", "qualname": "Bag", "type": "class", "doc": "<p>A class for bags of tree decompositions.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>idx (<code>int</code>):</strong>  The unique ID of this bag in the tree decomposition.</li>\n<li><strong>vertices (<code>set</code>):</strong>  The vertices in this bag.</li>\n<li><strong>children (<code>list</code>):</strong>  The children (also bags) of this bag in the tree decomposition.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>idx (<code>int</code>):</strong>  The unique ID of this bag in the tree decomposition.</li>\n<li><strong>vertices (<code>set</code>):</strong>  The vertices in this bag.</li>\n<li><strong>children (<code>list</code>):</strong>  The children (also bags) of this bag in the tree decomposition.</li>\n</ul>\n"}, {"fullname": "aspmc.graph.treedecomposition.Bag.__init__", "modulename": "aspmc.graph.treedecomposition", "qualname": "Bag.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "idx", "vertices", "children"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition", "type": "class", "doc": "<p>A class for tree decompositions.</p>\n\n<p>Allows manipulation and iteration in post order.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>bags (<code>int</code>):</strong>  The number of bags this tree decomposition has.</li>\n<li><strong>width (<code>int</code>):</strong>  The width of this tree decomposition.</li>\n<li><strong>vertices (<code>int</code>):</strong>  The number of vertices in this tree decomposition.</li>\n<li><strong>tree (<code>nx.Graph</code>):</strong>  The graph representing the actual tree decomposition. \nMust have a node attribute \"bag\" that contains all the vertices in the bag of the node.</li>\n<li><strong>root (<code>int</code>, optional):</strong>  Which node should be the root of the tree. Defaults to 1. </li>\n<li>The root is only set if this argument is not <code>None</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>bags (<code>int</code>):</strong>  The number of bags this tree decomposition has.</li>\n<li><strong>width (<code>int</code>):</strong>  The width of this tree decomposition.</li>\n<li><strong>vertices (<code>int</code>):</strong>  The number of vertices in this tree decomposition.</li>\n<li><strong>tree (<code>nx.Graph</code>):</strong>  The graph representing the actual tree decomposition. \nHas a node attribute \"bag\" that contains the bag object for the node. \n(Requires that <code>set_root</code> has been run already. This is typically done in the constructor if <code>root</code> is not <code>None</code>.)</li>\n<li><strong>root (<code>int</code>):</strong>  Which node is the root of the tree.</li>\n</ul>\n"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.__init__", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "bags", "width", "vertices", "tree", "root"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.get_root", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.get_root", "type": "function", "doc": "<p>Return the bag of the root node.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Bag</code>: The bag of the root node.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.get_bag", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.get_bag", "type": "function", "doc": "<p>Return the bag of given node.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>node (<code>int</code>):</strong>  The id of the node in the tree decomposition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Bag</code>: The bag of the node.</p>\n</blockquote>\n", "parameters": ["self", "node"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.set_root", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.set_root", "type": "function", "doc": "<p>Sets the root of the tree decomposition.\nUpdates the \"bag\" attributes of the tree so that the bags have the correct children.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>root (<code>int</code>):</strong>  The id of the root to be.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "root"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.find_centroid", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.find_centroid", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.bag_iter", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.bag_iter", "type": "function", "doc": "<p>Iterate over all the bags in post order.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>order (<code>string</code>, optional):</strong>  Which order the bags should be iterated over. </li>\n<li>Currently supported are \"post-order\" and \"pre-order\". Defaults to \"post-order\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>iterator</code>: Yields over the bags in the specified order.</p>\n</blockquote>\n", "parameters": ["self", "order"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.find_containing", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.find_containing", "type": "function", "doc": "<p>Find a bag containing all the vertices in <code>vertices</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vertices (<code>set</code>):</strong>  The vertices that should be contained in the desired bag.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>Bag</code>: A bag containg all the vertices in <code>vertices</code> or <code>None</code> if there is no such bag.</p>\n</blockquote>\n", "parameters": ["self", "vertices"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.remove", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.remove", "type": "function", "doc": "<p>Remove the vertices in <code>vertices</code> from all bags.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vertices (<code>set</code>):</strong>  The vertices that should be removed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "vertices"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.TreeDecomposition.draw", "modulename": "aspmc.graph.treedecomposition", "qualname": "TreeDecomposition.draw", "type": "function", "doc": "<p>Visualizes this tree decompisition by showing a plot of it. \nMostly useful for debugging.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.from_file", "modulename": "aspmc.graph.treedecomposition", "qualname": "from_file", "type": "function", "doc": "<p>Reads a tree decomposition from a file.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>path (<code>string</code>):</strong>  The path to the file containing the tree decomposition.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>TreeDecomposition</code>: The tree decomposition specified in the file.</p>\n</blockquote>\n", "parameters": ["path"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.from_stream", "modulename": "aspmc.graph.treedecomposition", "qualname": "from_stream", "type": "function", "doc": "<p>Reads a tree decomposition from a stream.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stream (<code>string</code>):</strong>  The stream with the tree decomposition. Must be binary.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>TreeDecomposition</code>: The tree decomposition specified in the stream.</p>\n</blockquote>\n", "parameters": ["stream"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.from_graph", "modulename": "aspmc.graph.treedecomposition", "qualname": "from_graph", "type": "function", "doc": "<p>Constructs a tree decomposition from a graph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>solver (<code>string</code>, optional):</strong>  The solver to generate the tree decomposition. </li>\n<li>Currently supported is \"flow-cutter\". Defaults to \"flow-cutter\".</li>\n<li><strong>timeout (<code>string</code>, optional):</strong>  After how much time to kill the solver in seconds. Defaults to \"1\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>TreeDecomposition</code>: The tree decomposition output by the solver.</p>\n</blockquote>\n", "parameters": ["graph", "solver", "timeout"], "funcdef": "def"}, {"fullname": "aspmc.graph.treedecomposition.from_hypergraph", "modulename": "aspmc.graph.treedecomposition", "qualname": "from_hypergraph", "type": "function", "doc": "<p>Constructs a tree decomposition from a hypergraph.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>solver (<code>string</code>, optional):</strong>  The solver to generate the tree decomposition. </li>\n<li>Currently supported is \"flow-cutter\". Defaults to \"flow-cutter\".</li>\n<li><strong>timeout (<code>string</code>, optional):</strong>  After how much time to kill the solver in seconds. Defaults to \"1\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>TreeDecomposition</code>: The tree decomposition output by the solver.</p>\n</blockquote>\n", "parameters": ["hypergraph", "solver", "timeout"], "funcdef": "def"}, {"fullname": "aspmc.main", "modulename": "aspmc.main", "qualname": "", "type": "module", "doc": "<p>Main module providing the application logic.</p>\n"}, {"fullname": "aspmc.main.addLoggingLevel", "modulename": "aspmc.main", "qualname": "addLoggingLevel", "type": "function", "doc": "<p>Comprehensively adds a new logging level to the <code>logging</code> module and the\ncurrently configured logging class.</p>\n\n<p><code>levelName</code> becomes an attribute of the <code>logging</code> module with the value\n<code>levelNum</code>. <code>methodName</code> becomes a convenience method for both <code>logging</code>\nitself and the class returned by <code>logging.getLoggerClass()</code> (usually just\n<code>logging.Logger</code>). If <code>methodName</code> is not specified, <code>levelName.lower()</code> is\nused.</p>\n\n<p>To avoid accidental clobberings of existing attributes, this method will\nraise an <code>AttributeError</code> if the level name is already an attribute of the\n<code>logging</code> module or if the method name is already present </p>\n\n<h2 id=\"example\">Example</h2>\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">addLoggingLevel</span><span class=\"p\">(</span><span class=\"s1\">&#39;TRACE&#39;</span><span class=\"p\">,</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span> <span class=\"o\">-</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">setLevel</span><span class=\"p\">(</span><span class=\"s2\">&quot;TRACE&quot;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">getLogger</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">trace</span><span class=\"p\">(</span><span class=\"s1\">&#39;that worked&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">trace</span><span class=\"p\">(</span><span class=\"s1\">&#39;so did this&#39;</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">TRACE</span>\n<span class=\"go\">5</span>\n</code></pre></div>\n", "parameters": ["levelName", "levelNum", "methodName"], "funcdef": "def"}, {"fullname": "aspmc.main.main", "modulename": "aspmc.main", "qualname": "main", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.parsing", "modulename": "aspmc.parsing", "qualname": "", "type": "module", "doc": "<p>The module aspmc.parsing contains all the parsing related classes:</p>\n\n<ul>\n<li>an ASP parser in aspmc.parsing.clingoparser, which parses ASP programs.</li>\n<li>an meu parser in aspmc.parsing.meu_parser, which parses Maximum Expected Utility ProbLog programs.</li>\n<li>a ProbLog parser in aspmc.parsing.parser, which parses (SM)ProbLog programs.</li>\n</ul>\n\n<p>Each parser has a corresponding semantics, that reads the parsed input and returns a program as a set of rules\nand optionally some special objects for queries, utilities etc.</p>\n\n<p>The parsers are (mostly) automatically generated using tatsu. The files to generate them are in the folder <code>grammars</code>.</p>\n"}, {"fullname": "aspmc.parsing.clingoparser", "modulename": "aspmc.parsing.clingoparser", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.clingoext", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Control", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Control", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Control.__init__", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Control.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "arguments", "logger", "message_limit", "control"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Control.ground", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Control.ground", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "parts", "context"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.__init__", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.rule", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "choice", "head", "body"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.output_atom", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.output_atom", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "symbol", "atom"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.weight_rule", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.weight_rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "choice", "head", "lower_bound", "body"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.project", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atoms"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Observer.external", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Observer.external", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atom", "value"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Application", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Application", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Application.__init__", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Application.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "application"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.Application.main", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "Application.main", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "control", "files"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.clingoext.clingo_main", "modulename": "aspmc.parsing.clingoparser.clingoext", "qualname": "clingo_main", "type": "function", "doc": "<p></p>\n", "parameters": ["application", "files"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoObject", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoObject", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoObject.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoObject.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoOutputAtom", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoOutputAtom", "type": "class", "doc": "<p>ClingoOutputAtom(symbol: clingo.symbol.Symbol, atom: int, order: int = 0)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoOutputAtom.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoOutputAtom.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "symbol", "atom", "order"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoOutputAtom.order", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoOutputAtom.order", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoRuleABC", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoRuleABC", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoRuleABC.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoRuleABC.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoRule", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoRule", "type": "class", "doc": "<p>ClingoRule(choice: bool, head: List[int], body: List[int], order: int = 1)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoRule.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoRule.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "choice", "head", "body", "order"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoRule.order", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoRule.order", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoProject", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoProject", "type": "class", "doc": "<p>ClingoProject(atoms: List[int], order: int = 3)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoProject.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoProject.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atoms", "order"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoProject.order", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoProject.order", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoExternal", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoExternal", "type": "class", "doc": "<p>ClingoExternal(atom, value)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoExternal.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoExternal.__init__", "type": "function", "doc": "<p>Create new instance of ClingoExternal(atom, value)</p>\n", "parameters": ["_cls", "atom", "value"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoExternal.atom", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoExternal.atom", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoExternal.value", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoExternal.value", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic", "type": "class", "doc": "<p>ClingoHeuristic(atom, type, bias, priority, condition)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.__init__", "type": "function", "doc": "<p>Create new instance of ClingoHeuristic(atom, type, bias, priority, condition)</p>\n", "parameters": ["_cls", "atom", "type", "bias", "priority", "condition"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.atom", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.atom", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.type", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.type", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.bias", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.bias", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.priority", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.priority", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoHeuristic.condition", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoHeuristic.condition", "type": "variable", "doc": "<p>Alias for field number 4</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoMinimize", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoMinimize", "type": "class", "doc": "<p>ClingoMinimize(priority, literals)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoMinimize.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoMinimize.__init__", "type": "function", "doc": "<p>Create new instance of ClingoMinimize(priority, literals)</p>\n", "parameters": ["_cls", "priority", "literals"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoMinimize.priority", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoMinimize.priority", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoMinimize.literals", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoMinimize.literals", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule", "type": "class", "doc": "<p>ClingoWeightRule(choice, head, body, lower)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule.__init__", "type": "function", "doc": "<p>Create new instance of ClingoWeightRule(choice, head, body, lower)</p>\n", "parameters": ["_cls", "choice", "head", "body", "lower"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule.choice", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule.choice", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule.head", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule.head", "type": "variable", "doc": "<p>Alias for field number 1</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule.body", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule.body", "type": "variable", "doc": "<p>Alias for field number 2</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoWeightRule.lower", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoWeightRule.lower", "type": "variable", "doc": "<p>Alias for field number 3</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoAssume", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoAssume", "type": "class", "doc": "<p>ClingoAssume(literals,)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoAssume.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoAssume.__init__", "type": "function", "doc": "<p>Create new instance of ClingoAssume(literals,)</p>\n", "parameters": ["_cls", "literals"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.ClingoAssume.literals", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "ClingoAssume.literals", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram", "type": "class", "doc": "<p>GroundProgram(objects: Iterable[aspmc.parsing.clingoparser.groundprogram.ClingoObject] = [])</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "objects"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram.add_rule", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram.add_rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "choice", "head", "body"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram.add_rules", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram.add_rules", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rules"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram.add_project", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram.add_project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atoms"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.GroundProgram.add", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "GroundProgram.add", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "obj"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyClingoOject", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyClingoOject", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyClingoOject.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyClingoOject.__init__", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyRule", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyRule", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyRule.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyRule.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "choice", "head", "body"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyProjection", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyProjection", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyProjection.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyProjection.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atoms"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyExternal", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyExternal", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyExternal.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyExternal.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atom", "value"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.__init__", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add_rule", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add_rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rule"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add_rules", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add_rules", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "rules"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add_projection", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add_projection", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "projection"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add_external", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add_external", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "external"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.add_project", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.add_project", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atoms"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.groundprogram.PrettyGroundProgram.sort", "modulename": "aspmc.parsing.clingoparser.groundprogram", "qualname": "PrettyGroundProgram.sort", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.literals", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.literals.Literal", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "Literal", "type": "class", "doc": "<p>Literal(atom: clingo.symbol.Symbol, sign: Union[clingo.ast.Sign, bool])</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.literals.Literal.__init__", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "Literal.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "atom", "sign"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.literals.EpistemicLiteral", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "EpistemicLiteral", "type": "class", "doc": "<p>EpistemicLiteral(literal: aspmc.parsing.clingoparser.literals.Literal, sign: clingo.ast.Sign = <Sign.NoSign: 0>)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.literals.EpistemicLiteral.__init__", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "EpistemicLiteral.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "literal", "sign"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.literals.EpistemicLiteral.sign", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "EpistemicLiteral.sign", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.clingoparser.literals.WorldView", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "WorldView", "type": "class", "doc": "<p>WorldView(symbols,)</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.literals.WorldView.__init__", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "WorldView.__init__", "type": "function", "doc": "<p>Create new instance of WorldView(symbols,)</p>\n", "parameters": ["_cls", "symbols"], "funcdef": "def"}, {"fullname": "aspmc.parsing.clingoparser.literals.WorldView.symbols", "modulename": "aspmc.parsing.clingoparser.literals", "qualname": "WorldView.symbols", "type": "variable", "doc": "<p>Alias for field number 0</p>\n"}, {"fullname": "aspmc.parsing.clingoparser.sign", "modulename": "aspmc.parsing.clingoparser.sign", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.lark_parser", "modulename": "aspmc.parsing.lark_parser", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.parsing.lark_parser.ProbabilisticRule", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProbabilisticRule", "type": "class", "doc": "<p>A class for probabilistic rules.</p>\n\n<p>If a rule has more than one atom in the head, the head must be an annotated disjunction.\nThen each of the atoms must have a weight.</p>\n\n<p>Implements a custom <code>__str__</code> method.</p>\n\n<p>Args: <br />\n    head (<code>list</code>): The list of head atoms. May be empty.\n    body (<code>list</code>): The list of body atoms. May be empty.\n    weights (<code>list</code>): The list of weights of the head atoms. May be empty.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>head (<code>list</code>):</strong>  The list of head atoms. May be empty.</li>\n<li><strong>body (<code>list</code>):</strong>  The list of body atoms. May be empty.</li>\n<li><strong>weights (<code>list</code>):</strong>  The list of weights of the head atoms. May be empty.</li>\n</ul>\n"}, {"fullname": "aspmc.parsing.lark_parser.ProbabilisticRule.__init__", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProbabilisticRule.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "head", "body", "weights"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProbabilisticRule.asp_string", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProbabilisticRule.asp_string", "type": "function", "doc": "<p>Generates an ASP representation of the rule.</p>\n\n<p>Implements a custom <code>__str__</code> method.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>string</code>: The representation of this rule as an ASP rule.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.Atom", "modulename": "aspmc.parsing.lark_parser", "qualname": "Atom", "type": "class", "doc": "<p>A class for atoms.</p>\n\n<p>Implements a custom <code>__str__</code> method.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>predicate (<code>string</code>):</strong>  The predicate of the atom.</li>\n<li><strong>inputs (<code>list</code>, optional):</strong>  The inputs of the atom. </li>\n<li>These may be strings or other atoms. </li>\n<li>Defaults to <code>None</code>.</li>\n<li><strong>negated (<code>bool</code>, optional):</strong>  Whether the atom is negated.</li>\n<li>Defaults to <code>False</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>predicate (<code>string</code>):</strong>  The predicate of the atom.</li>\n<li><strong>inputs (<code>list</code>, optional):</strong>  The inputs of the atom. </li>\n<li>These may be strings or other atoms. </li>\n<li><strong>negated (<code>bool</code>, optional):</strong>  Whether the atom is negated.</li>\n</ul>\n"}, {"fullname": "aspmc.parsing.lark_parser.Atom.__init__", "modulename": "aspmc.parsing.lark_parser", "qualname": "Atom.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "predicate", "inputs", "negated"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.Atom.get_variables", "modulename": "aspmc.parsing.lark_parser", "qualname": "Atom.get_variables", "type": "function", "doc": "<p>Rcursively finds all the variables used in the atom.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: The list of variables as strings.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer", "type": "class", "doc": "<p>The corresponding ProbLog semantics class for the ProbLog parser class in aspmc.parsing.parser.</p>\n\n<p>See the tatsu documentation for how this works.</p>\n"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.program", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.program", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.rule", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.fact", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.fact", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.normal_rule", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.normal_rule", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.annotated_disjunction", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.annotated_disjunction", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.body", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.body", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.constraint", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.constraint", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.atom", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.atom", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.input", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.input", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.term", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.term", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.variable", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.variable", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.parsing.lark_parser.ProblogTransformer.weight", "modulename": "aspmc.parsing.lark_parser", "qualname": "ProblogTransformer.weight", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.programs", "modulename": "aspmc.programs", "qualname": "", "type": "module", "doc": "<p>The module aspmc.programs contains different program modules:</p>\n\n<ul>\n<li>aspmc.programs.program: The base class, without extras. \nThis is the base class for all the other program classes and performs the cycle breaking,\nas well as the clark completion afterwards.</li>\n<li>aspmc.programs.algebraicprogram: Adds weights for atoms over a semiring. \nTakes care of transforming programs so that all guesses are independent.\nFurthermore, normalizes the program so that no annotated disjunctions occur.</li>\n<li>aspmc.programs.twoalgebraicprogram: Adds weights over two different semirings for different atoms. \nAbstract class, that is meant to be subclassed.</li>\n<li>aspmc.programs.smprogram: is a special twoalgebraicprogram that computes a normalized weighted answer set count,</li>\n<li>aspmc.programs.meuprogram: is a special twoalgebraicprogram that computes the maximum expected utility of \na problog program with a set of decisions.  </li>\n</ul>\n\n<p>These classes can transform a program into an extended cnf (see aspmc.compile.cnf)\nthat can be compiled to obtain the algebraic answer set count.</p>\n"}, {"fullname": "aspmc.programs.algebraicprogram", "modulename": "aspmc.programs.algebraicprogram", "qualname": "", "type": "module", "doc": "<p>Program module providing the algebraic progam class.</p>\n"}, {"fullname": "aspmc.programs.algebraicprogram.AlgebraicProgram", "modulename": "aspmc.programs.algebraicprogram", "qualname": "AlgebraicProgram", "type": "class", "doc": "<p>A class for programs with weights over semirings. </p>\n\n<p>Should be specified in ProbLog syntax, but allows negations and negative cycles.</p>\n\n<p>Annotated disjunctions are theoretically supported over any semiring but the results are likely to \nbe wrong over semirings that differ from the probabilistic semiring.</p>\n\n<p>Grounding of these programs (and subclasses thereof) should follow the following strategy:</p>\n\n<ul>\n<li><code>_prepare_grounding(self, program)</code> should take the output of the parser \n(i.e. a list of rules and special objects) and process all the rules and special objects\ntransforming them either into other rules or into strings that can be given to the grounder.</li>\n<li><p>the output of <code>_prepare_grounding(self, program)</code> is transformed to one program string via</p>\n\n<pre><code>'\\n'.join([ str(r) for r in program ])\n</code></pre>\n\n<p>This string will be given to the grounder, which produces a clingo control object.</p></li>\n<li><code>_process_grounding(self, clingo_control)</code> should take this clingo control object and process the\ngrounding in an appropriate way (and draw some information from it optionally about weights, special objects).\nThe resulting processed clingo_control object must only know about the \nrules that should be seen in the base program class.</li>\n</ul>\n\n<p>Thus, subclasses can override <code>_prepare_grounding</code> and <code>_process_grounding</code> (and optionally call the superclass methods) \nto handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>ProbLog syntax that should be included. May be an empty list.</li>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. See aspmc.semiring for how they should look.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. </li>\n<li><strong>weights (<code>dict</code>):</strong>  The dictionary from atom names to their weight.</li>\n<li><strong>queries (<code>list</code>):</strong>  The list of atoms to be queries in their string representation.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.algebraicprogram.AlgebraicProgram.__init__", "modulename": "aspmc.programs.algebraicprogram", "qualname": "AlgebraicProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files", "semiring"], "funcdef": "def"}, {"fullname": "aspmc.programs.algebraicprogram.AlgebraicProgram.get_weights", "modulename": "aspmc.programs.algebraicprogram", "qualname": "AlgebraicProgram.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.algebraicprogram.AlgebraicProgram.get_queries", "modulename": "aspmc.programs.algebraicprogram", "qualname": "AlgebraicProgram.get_queries", "type": "function", "doc": "<p>Get the queries (names not literals). </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of queries. \n      The empty list corresponds to asking for the overall weight of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.backdoor", "modulename": "aspmc.programs.backdoor", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.programs.backdoor.safe_int", "modulename": "aspmc.programs.backdoor", "qualname": "safe_int", "type": "function", "doc": "<p></p>\n", "parameters": ["string"], "funcdef": "def"}, {"fullname": "aspmc.programs.backdoor.ClingoControl", "modulename": "aspmc.programs.backdoor", "qualname": "ClingoControl", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.programs.backdoor.ClingoControl.__init__", "modulename": "aspmc.programs.backdoor", "qualname": "ClingoControl.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "prog"], "funcdef": "def"}, {"fullname": "aspmc.programs.backdoor.ClingoControl.get_backdoor", "modulename": "aspmc.programs.backdoor", "qualname": "ClingoControl.get_backdoor", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "encodingFile", "timeout", "usc", "solve_limit"], "funcdef": "def"}, {"fullname": "aspmc.programs.grounder", "modulename": "aspmc.programs.grounder", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.programs.grounder.ground", "modulename": "aspmc.programs.grounder", "qualname": "ground", "type": "function", "doc": "<p></p>\n", "parameters": ["control", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.mapprogram", "modulename": "aspmc.programs.mapprogram", "qualname": "", "type": "module", "doc": "<p>Maximum A Posteriori Program module specializing the TwoAlgebraicProgam class.</p>\n"}, {"fullname": "aspmc.programs.mapprogram.MAPProblogProgram", "modulename": "aspmc.programs.mapprogram", "qualname": "MAPProblogProgram", "type": "class", "doc": "<p>A class for Maximum A Posteriori programs. </p>\n\n<p>The syntax for these programs is the same as for ProbLog in MAP mode. \nThis means that the probabilistic part is specified as usual,\nevidence atoms <code>a</code>, i.e. atoms that are true, must be given as <code>evidence(a).</code> and\nthe MAP query atoms <code>q</code>, whose assignment should be maximized over should be given as <code>query(q).</code>.</p>\n\n<p>Note that these atoms can be any atom and need not be probabilistic facts.</p>\n\n<p>Subclasses <code>TwoAlgebraicProgram</code> since it is a second level problem.</p>\n\n<p>Overrides the <code>_prepare_grounding</code> method to deal with MAP query atoms and evidence.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in MAP ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>MAP ProbLog syntax that should be included. May be an empty list.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.mapprogram.MAPProblogProgram.__init__", "modulename": "aspmc.programs.mapprogram", "qualname": "MAPProblogProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.mapprogram.MAPProblogProgram.to_pita", "modulename": "aspmc.programs.mapprogram", "qualname": "MAPProblogProgram.to_pita", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.meuprogram", "modulename": "aspmc.programs.meuprogram", "qualname": "", "type": "module", "doc": "<p>Maximum Expected Utility Program module specializing the TwoAlgebraicProgam class.</p>\n"}, {"fullname": "aspmc.programs.meuprogram.MEUProblogProgram", "modulename": "aspmc.programs.meuprogram", "qualname": "MEUProblogProgram", "type": "class", "doc": "<p>A class for Maximum Expected Utility programs. </p>\n\n<p>The syntax for these programs is the same as for ProbLog in MEU mode. \nThis means that the probabilistic part is specified as usual,\nutility atoms <code>a</code>, i.e. atoms whose truth adds utility value <code>u</code> to the model, must be given as <code>utility(a, u).</code> and\nthe decision atoms <code>d</code>, whose assignment should be maximized over should be given as <code>decision(d).</code>.</p>\n\n<p>Subclasses <code>TwoAlgebraicProgram</code> since it is a second level problem.</p>\n\n<p>Overrides the <code>_prepare_grounding</code> method to deal with utilities and decisions.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in MEU ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>MEU ProbLog syntax that should be included. May be an empty list.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.meuprogram.MEUProblogProgram.__init__", "modulename": "aspmc.programs.meuprogram", "qualname": "MEUProblogProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.meuprogram.MEUProblogProgram.to_pita", "modulename": "aspmc.programs.meuprogram", "qualname": "MEUProblogProgram.to_pita", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.mpeprogram", "modulename": "aspmc.programs.mpeprogram", "qualname": "", "type": "module", "doc": "<p>Program module providing the algebraic progam class.</p>\n"}, {"fullname": "aspmc.programs.mpeprogram.MPEProblogProgram", "modulename": "aspmc.programs.mpeprogram", "qualname": "MPEProblogProgram", "type": "class", "doc": "<p>A class for programs with weights over semirings. </p>\n\n<p>Should be specified in ProbLog syntax, but allows negations and negative cycles.</p>\n\n<p>Annotated disjunctions are theoretically supported over any semiring but the results are likely to \nbe wrong over semirings that differ from the probabilistic semiring.</p>\n\n<p>Grounding of these programs (and subclasses thereof) should follow the following strategy:</p>\n\n<ul>\n<li><code>_prepare_grounding(self, program)</code> should take the output of the parser \n(i.e. a list of rules and special objects) and process all the rules and special objects\ntransforming them either into other rules or into strings that can be given to the grounder.</li>\n<li><p>the output of <code>_prepare_grounding(self, program)</code> is transformed to one program string via</p>\n\n<pre><code>'\\n'.join([ str(r) for r in program ])\n</code></pre>\n\n<p>This string will be given to the grounder, which produces a clingo control object.</p></li>\n<li><code>_process_grounding(self, clingo_control)</code> should take this clingo control object and process the\ngrounding in an appropriate way (and draw some information from it optionally about weights, special objects).\nThe resulting processed clingo_control object must only know about the \nrules that should be seen in the base program class.</li>\n</ul>\n\n<p>Thus, subclasses can override <code>_prepare_grounding</code> and <code>_process_grounding</code> (and optionally call the superclass methods) \nto handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>ProbLog syntax that should be included. May be an empty list.</li>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. See aspmc.semiring for how they should look.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. </li>\n<li><strong>weights (<code>dict</code>):</strong>  The dictionary from atom names to their weight.</li>\n<li><strong>queries (<code>list</code>):</strong>  The list of atoms to be queries in their string representation.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.mpeprogram.MPEProblogProgram.__init__", "modulename": "aspmc.programs.mpeprogram", "qualname": "MPEProblogProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.mpeprogram.MPEProblogProgram.get_weights", "modulename": "aspmc.programs.mpeprogram", "qualname": "MPEProblogProgram.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.mpeprogram.MPEProblogProgram.get_queries", "modulename": "aspmc.programs.mpeprogram", "qualname": "MPEProblogProgram.get_queries", "type": "function", "doc": "<p>Get the queries (names not literals). </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of queries. \n      The empty list corresponds to asking for the overall weight of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.naming", "modulename": "aspmc.programs.naming", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.programs.problogprogram", "modulename": "aspmc.programs.problogprogram", "qualname": "", "type": "module", "doc": "<p>Program module providing the algebraic progam class.</p>\n"}, {"fullname": "aspmc.programs.problogprogram.ProblogProgram", "modulename": "aspmc.programs.problogprogram", "qualname": "ProblogProgram", "type": "class", "doc": "<p>A class for programs with weights over semirings. </p>\n\n<p>Should be specified in ProbLog syntax, but allows negations and negative cycles.</p>\n\n<p>Annotated disjunctions are theoretically supported over any semiring but the results are likely to \nbe wrong over semirings that differ from the probabilistic semiring.</p>\n\n<p>Grounding of these programs (and subclasses thereof) should follow the following strategy:</p>\n\n<ul>\n<li><code>_prepare_grounding(self, program)</code> should take the output of the parser \n(i.e. a list of rules and special objects) and process all the rules and special objects\ntransforming them either into other rules or into strings that can be given to the grounder.</li>\n<li><p>the output of <code>_prepare_grounding(self, program)</code> is transformed to one program string via</p>\n\n<pre><code>'\\n'.join([ str(r) for r in program ])\n</code></pre>\n\n<p>This string will be given to the grounder, which produces a clingo control object.</p></li>\n<li><code>_process_grounding(self, clingo_control)</code> should take this clingo control object and process the\ngrounding in an appropriate way (and draw some information from it optionally about weights, special objects).\nThe resulting processed clingo_control object must only know about the \nrules that should be seen in the base program class.</li>\n</ul>\n\n<p>Thus, subclasses can override <code>_prepare_grounding</code> and <code>_process_grounding</code> (and optionally call the superclass methods) \nto handle their extras. See aspmc.programs.meuprogram or aspmc.programs.smprogram for examples.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>ProbLog syntax that should be included. May be an empty list.</li>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. See aspmc.semiring for how they should look.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>semiring (<code>module</code>):</strong>  The semiring module to be used. </li>\n<li><strong>weights (<code>dict</code>):</strong>  The dictionary from atom names to their weight.</li>\n<li><strong>queries (<code>list</code>):</strong>  The list of atoms to be queries in their string representation.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.problogprogram.ProblogProgram.__init__", "modulename": "aspmc.programs.problogprogram", "qualname": "ProblogProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.problogprogram.ProblogProgram.get_weights", "modulename": "aspmc.programs.problogprogram", "qualname": "ProblogProgram.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.problogprogram.ProblogProgram.get_queries", "modulename": "aspmc.programs.problogprogram", "qualname": "ProblogProgram.get_queries", "type": "function", "doc": "<p>Get the queries (names not literals). </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of queries. \n      The empty list corresponds to asking for the overall weight of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program", "modulename": "aspmc.programs.program", "qualname": "", "type": "module", "doc": "<p>Program module providing the progam class with cycle breaking methods and clark completion(s).</p>\n"}, {"fullname": "aspmc.programs.program.UnsupportedException", "modulename": "aspmc.programs.program", "qualname": "UnsupportedException", "type": "class", "doc": "<p>raise this when the program relies on features that are not supported yet</p>\n"}, {"fullname": "aspmc.programs.program.Rule", "modulename": "aspmc.programs.program", "qualname": "Rule", "type": "class", "doc": "<p>A class for rules.</p>\n\n<p>Implements a custom <code>__repr__</code> method.</p>\n\n<p>Args: <br />\n    head (<code>list</code>): The list of head atoms as dimacs literals. May be empty.\n    body (<code>list</code>): The list of body atoms as dimacs literals. May be empty.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>head (<code>list</code>):</strong>  The list of head atoms as dimacs literals. May be empty.</li>\n<li><strong>body (<code>list</code>):</strong>  The list of body atoms as dimacs literals. May be empty.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.program.Rule.__init__", "modulename": "aspmc.programs.program", "qualname": "Rule.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "head", "body"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program", "modulename": "aspmc.programs.program", "qualname": "Program", "type": "class", "doc": "<p>A base class for programs. No weights, no queries this is only for getting a cnf representation of the program.</p>\n\n<p>Allowed features are: </p>\n\n<ul>\n<li>facts</li>\n<li>normal rules</li>\n<li>unconditional choice constraints</li>\n<li>constraints</li>\n</ul>\n\n<p>The cnf is generated by first doing Tp-Unfolding and then applying a Clark completion to the resulting tight program. </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in ASP syntax. \nMay be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in ASP syntax \nthat should be included. May be an empty list.</li>\n<li><strong>clingo_control (<code>Control</code>):</strong>  A clingo control object that contains parts of the program. \nMust already be ground if no non-empty <code>program_str</code> or <code>program_files</code> are given.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.program.Program.__init__", "modulename": "aspmc.programs.program", "qualname": "Program.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "clingo_control", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.treeprocess", "modulename": "aspmc.programs.program", "qualname": "Program.treeprocess", "type": "function", "doc": "<p>Applies tree processing to the program. </p>\n\n<p>This means that if there is a part of the dependency graph that is a tree and\nonly has one connection to the rest of the dependency graph, then it will be processed.</p>\n\n<p>Results in one copy for each atom in the tree.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.tpUnfold", "modulename": "aspmc.programs.program", "qualname": "Program.tpUnfold", "type": "function", "doc": "<p>Applies Tp-Unfolding to the program. </p>\n\n<p>Applies a variant to be precise by first doing treeprocessing\nand then Tp-Unfolding as this can be a bit better.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.binary_cycle_breaking", "modulename": "aspmc.programs.program", "qualname": "Program.binary_cycle_breaking", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "local"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.less_than_cycle_breaking", "modulename": "aspmc.programs.program", "qualname": "Program.less_than_cycle_breaking", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "opt"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.clark_completion", "modulename": "aspmc.programs.program", "qualname": "Program.clark_completion", "type": "function", "doc": "<p>Applies the clark completion to the program. </p>\n\n<p>Does not check whether the program is tight! \nDoes not use tree decomposition guidance to obtain a program of possibly smaller treewidth.</p>\n\n<p>Does not return anything only constructs the cnf.\nThe CNF can be obtained by using <code>get_cnf()</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.td_guided_clark_completion", "modulename": "aspmc.programs.program", "qualname": "Program.td_guided_clark_completion", "type": "function", "doc": "<p>Applies the clark completion to the program. </p>\n\n<p>Does not check whether the program is tight! \nUse tree decomposition guidance on the \"ors\" to obtain a program of possibly smaller treewidth.</p>\n\n<p>Does not return anything only constructs the cnf.\nThe CNF can be obtained by using <code>get_cnf()</code>.</p>\n\n<p>The solver to compute the tree decomposition and its timeout can be specified in \naspmc.config.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.td_guided_both_clark_completion", "modulename": "aspmc.programs.program", "qualname": "Program.td_guided_both_clark_completion", "type": "function", "doc": "<p>Applies the clark completion to the program. </p>\n\n<p>Does not check whether the program is tight! \nUse tree decomposition guidance on both the \"ands\" and the \"ors\"\nto obtain a program of possibly smaller treewidth.</p>\n\n<p>Does not return anything only constructs the cnf.\nThe CNF can be obtained by using <code>get_cnf()</code>.</p>\n\n<p>The solver to compute the tree decomposition and its timeout can be specified in \naspmc.config.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.encoding_stats", "modulename": "aspmc.programs.program", "qualname": "Program.encoding_stats", "type": "function", "doc": "<p>Print the stats of a tree decomposition of the cnf. </p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.get_cnf", "modulename": "aspmc.programs.program", "qualname": "Program.get_cnf", "type": "function", "doc": "<p>Used to get the extended cnf corresponding to the program. </p>\n\n<p>Only possible after having called <code>tpUnfold()</code> and one of the Clark completion methods.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>aspmc.compile.cnf.CNF</code>: Returns the extended cnf of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.write_dimacs", "modulename": "aspmc.programs.program", "qualname": "Program.write_dimacs", "type": "function", "doc": "<p>Write the extended cnf corresponding to the program to a stream. </p>\n\n<p>Only possible after having called <code>tpUnfold()</code> and one of the Clark completion methods.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stream (<code>stream</code>):</strong>  The stream to write to. Must be binary.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>aspmc.compile.cnf.CNF</code>: Returns the extended cnf of the program.</p>\n</blockquote>\n", "parameters": ["self", "stream", "kwargs"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.write_prog", "modulename": "aspmc.programs.program", "qualname": "Program.write_prog", "type": "function", "doc": "<p>Write the (spanning) program to a stream.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stream (<code>stream</code>):</strong>  The stream to write to. Must be binary.</li>\n<li><strong>spanning (<code>bool</code>, optional):</strong>  Whether the to write (case <code>False</code>) the actual program,\npossibly with weights and utilities and such or (case <code>True</code>) only the spanning program. \nThe spanning program corresponds to the underlying logical theory.\nDefaults to <code>False</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "parameters": ["self", "stream", "spanning"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.get_weights", "modulename": "aspmc.programs.program", "qualname": "Program.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.program.Program.get_queries", "modulename": "aspmc.programs.program", "qualname": "Program.get_queries", "type": "function", "doc": "<p>Get the queries (names not literals). </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of queries. \n      The empty list corresponds to asking for the overall weight of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.smprogram", "modulename": "aspmc.programs.smprogram", "qualname": "", "type": "module", "doc": "<p>Program module providing the smprogam class.</p>\n"}, {"fullname": "aspmc.programs.smprogram.SMProblogProgram", "modulename": "aspmc.programs.smprogram", "qualname": "SMProblogProgram", "type": "class", "doc": "<p>A class for SMProbLog programs. </p>\n\n<p>Subclasses <code>TwoAlgebraicProgram</code> since it is a second level problem.</p>\n\n<p>Overrides the <code>_prepare_grounding</code> method to deal with negative atoms in the head in the same way as ProbLog.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>program_str (<code>string</code>):</strong>  A string containing a part of the program in ProbLog syntax. </li>\n<li>May be the empty string.</li>\n<li><strong>program_files (<code>list</code>):</strong>  A list of string that are paths to files which contain programs in </li>\n<li>ProbLog syntax that should be included. May be an empty list.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.smprogram.SMProblogProgram.__init__", "modulename": "aspmc.programs.smprogram", "qualname": "SMProblogProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program_str", "program_files"], "funcdef": "def"}, {"fullname": "aspmc.programs.smprogram.SMProblogProgram.get_weights", "modulename": "aspmc.programs.smprogram", "qualname": "SMProblogProgram.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.twoalgebraicprogram", "modulename": "aspmc.programs.twoalgebraicprogram", "qualname": "", "type": "module", "doc": "<p>Program module providing the two algebraic progam class.</p>\n"}, {"fullname": "aspmc.programs.twoalgebraicprogram.TwoAlgebraicProgram", "modulename": "aspmc.programs.twoalgebraicprogram", "qualname": "TwoAlgebraicProgram", "type": "class", "doc": "<p>A class for programs with weights over two semirings. </p>\n\n<p>This is supposed to be an abstract class in the sense that it should used and instantiated\nby subclasses, rather than parsed itself.</p>\n\n<p>Overrides the <code>get_weights</code>, <code>_finalize_cnf</code> and <code>get_queries</code> methods appropriately.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>clingo_control (<code>Control</code>):</strong>  The clingo control object having the rules of the spanning program.</li>\n<li><strong>first_semiring (<code>module</code>):</strong>  The first semiring module.</li>\n<li><strong>second_semiring (<code>module</code>):</strong>  The second semiring module.</li>\n<li><strong>first_weights (<code>dict</code>):</strong>  The weights over the first semiring. \nNeeds to map pairs <code>(name, phase)</code>, where <code>name</code> is the name of an atom \nand <code>phase</code> is its polarity (<code>True</code> for true), to their weight.</li>\n<li><strong>second_weights (<code>dict</code>):</strong>  The weights over the second semiring. \nNeeds to map pairs <code>(name, phase)</code>, where <code>name</code> is the name of an atom \nand <code>phase</code> is its polarity (<code>True</code> for true), to their weight.</li>\n<li><strong>transform (<code>string</code>):</strong>  A string representation of the function that transforms a value from the first\ninto a value from the second semiring.</li>\n<li><strong>queries (<code>list</code>):</strong>  A list of names of atoms that should be queried. \nSpecify the empty list for an overall weight query.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>first_semiring (<code>module</code>):</strong>  The first semiring module.</li>\n<li><strong>second_semiring (<code>module</code>):</strong>  The second semiring module.</li>\n<li><strong>first_weights (<code>dict</code>):</strong>  The weights over the first semiring. \nNeeds to map pairs <code>(name, phase)</code>, where <code>name</code> is the name of an atom \nand <code>phase</code> is its polarity (<code>True</code> for true), to their weight.</li>\n<li><strong>second_weights (<code>dict</code>):</strong>  The weights over the second semiring. \nNeeds to map pairs <code>(name, phase)</code>, where <code>name</code> is the name of an atom \nand <code>phase</code> is its polarity (<code>True</code> for true), to their weight.</li>\n<li><strong>transform (<code>string</code>):</strong>  A string representation of the function that transforms a value from the first\ninto a value from the second semiring.</li>\n<li><strong>queries (<code>list</code>):</strong>  A list of names of atoms that should be queried. \nSpecify the empty list for an overall weight query.</li>\n</ul>\n"}, {"fullname": "aspmc.programs.twoalgebraicprogram.TwoAlgebraicProgram.__init__", "modulename": "aspmc.programs.twoalgebraicprogram", "qualname": "TwoAlgebraicProgram.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "clingo_control", "first_semiring", "second_semiring", "first_weights", "second_weights", "transform", "queries"], "funcdef": "def"}, {"fullname": "aspmc.programs.twoalgebraicprogram.TwoAlgebraicProgram.get_weights", "modulename": "aspmc.programs.twoalgebraicprogram", "qualname": "TwoAlgebraicProgram.get_weights", "type": "function", "doc": "<p>Get the weights of all the literals. </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of <code>weights</code> as numpy arrays. <br />\n      The weight of literal <code>v</code> is in <code>weights[2*(v-1)]</code>, the one for <code>-v</code> is in <code>weights[2*(v-1)+1]</code></p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.programs.twoalgebraicprogram.TwoAlgebraicProgram.get_queries", "modulename": "aspmc.programs.twoalgebraicprogram", "qualname": "TwoAlgebraicProgram.get_queries", "type": "function", "doc": "<p>Get the queries (names not literals). </p>\n\n<p>Should be overwritten by subclasses.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p><code>list</code>: A list of queries. \n      The empty list corresponds to asking for the overall weight of the program.</p>\n</blockquote>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.semirings", "modulename": "aspmc.semirings", "qualname": "", "type": "module", "doc": "<p>The aspmc.semirings module contains a collection of semiring submodules:</p>\n\n<ul>\n<li>grad: gradient semiring,</li>\n<li>maxplus: max tropical semiring,</li>\n<li>probabilistic: probabilistic semiring,</li>\n<li>two_nat: crossproduct of the natural number semiring with itself.  </li>\n</ul>\n\n<p>They follow a simple format, thus this library can be easily extended with custom semirings.</p>\n\n<p>Namely, a semiring module must provide the following functions and attributes:</p>\n\n<pre><code>def parse(value, atom = None):\n    pass\n\ndef from_value(value):\n    pass\n\ndef negate(value):\n    pass\n\ndef to_string(value):\n    pass\n\ndef zero():\n    pass\n\ndef one():\n    pass\n\ndtype = object\npattern = '.*'\n</code></pre>\n\n<p>Here</p>\n\n<ul>\n<li><code>parse</code> must take the string representation of a value and an atom and return the object corresponding to the value.</li>\n<li><code>from_value</code> must take an object <code>value</code> that represents a value and return the object corresponding to the value.\nHow the value object looks is up to the implementer.</li>\n<li><code>negate</code> must take an object corresponding to a value and return the object corresponding to the negation of the value.\nHow this negation works is up to the implementer.</li>\n<li><code>to_string</code> must take an object corresponding to a value and return a string representation of it that results in the \nsame object when parsed again with <code>parse</code>.</li>\n<li><code>zero</code> must return a (copy of) the object representing the zero element of the semiring.</li>\n<li><code>one</code> must return a (copy of) the object representing the one element of the semiring.</li>\n<li><code>dtype</code> is the type that should be used to instantiate numpy arrays of values from this semiring.</li>\n<li><code>pattern</code> is a string corresponding to a regex pattern that string representations of values from this semiring\nmust match.</li>\n</ul>\n\n<p>The objects returned by <code>parse</code>, <code>from_value</code> and <code>negated</code> must implement <code>__add__(self, other)</code>, <code>__iadd__(self, other)</code>,\n<code>__mul__(self, other)</code> and <code>__imul__(self, other)</code>, where <code>other</code> is an object of the same type.</p>\n\n<p>Examples are in the included semiring submodules.</p>\n"}, {"fullname": "aspmc.semirings.grad", "modulename": "aspmc.semirings.grad", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.grad.Gradient", "modulename": "aspmc.semirings.grad", "qualname": "Gradient", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.grad.Gradient.__init__", "modulename": "aspmc.semirings.grad", "qualname": "Gradient.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.parse", "modulename": "aspmc.semirings.grad", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.from_value", "modulename": "aspmc.semirings.grad", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.negate", "modulename": "aspmc.semirings.grad", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.to_string", "modulename": "aspmc.semirings.grad", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.is_idempotent", "modulename": "aspmc.semirings.grad", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.zero", "modulename": "aspmc.semirings.grad", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.grad.one", "modulename": "aspmc.semirings.grad", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus", "modulename": "aspmc.semirings.maxplus", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplus.MaxPlusFloat", "modulename": "aspmc.semirings.maxplus", "qualname": "MaxPlusFloat", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplus.MaxPlusFloat.__init__", "modulename": "aspmc.semirings.maxplus", "qualname": "MaxPlusFloat.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.parse", "modulename": "aspmc.semirings.maxplus", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.from_value", "modulename": "aspmc.semirings.maxplus", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.negate", "modulename": "aspmc.semirings.maxplus", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.to_string", "modulename": "aspmc.semirings.maxplus", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.is_idempotent", "modulename": "aspmc.semirings.maxplus", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.zero", "modulename": "aspmc.semirings.maxplus", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplus.one", "modulename": "aspmc.semirings.maxplus", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplusdecisions.MaxPlusFloat", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "MaxPlusFloat", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplusdecisions.MaxPlusFloat.__init__", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "MaxPlusFloat.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "decisions"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.parse", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.from_value", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.negate", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.to_string", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.is_idempotent", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.zero", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusdecisions.one", "modulename": "aspmc.semirings.maxplusdecisions", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplusgradient.MaxPlusGradient", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "MaxPlusGradient", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxplusgradient.MaxPlusGradient.__init__", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "MaxPlusGradient.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.parse", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.from_value", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.negate", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.to_string", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.is_idempotent", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.zero", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxplusgradient.one", "modulename": "aspmc.semirings.maxplusgradient", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes", "modulename": "aspmc.semirings.maxtimes", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxtimes.MaxTimesFloat", "modulename": "aspmc.semirings.maxtimes", "qualname": "MaxTimesFloat", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxtimes.MaxTimesFloat.__init__", "modulename": "aspmc.semirings.maxtimes", "qualname": "MaxTimesFloat.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.parse", "modulename": "aspmc.semirings.maxtimes", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.from_value", "modulename": "aspmc.semirings.maxtimes", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.negate", "modulename": "aspmc.semirings.maxtimes", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.to_string", "modulename": "aspmc.semirings.maxtimes", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.is_idempotent", "modulename": "aspmc.semirings.maxtimes", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.zero", "modulename": "aspmc.semirings.maxtimes", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimes.one", "modulename": "aspmc.semirings.maxtimes", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxtimesdecisions.MaxTimesFloat", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "MaxTimesFloat", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.maxtimesdecisions.MaxTimesFloat.__init__", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "MaxTimesFloat.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "value", "decisions"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.parse", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.from_value", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.negate", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.to_string", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.zero", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.maxtimesdecisions.one", "modulename": "aspmc.semirings.maxtimesdecisions", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic", "modulename": "aspmc.semirings.probabilistic", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.probabilistic.parse", "modulename": "aspmc.semirings.probabilistic", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["f", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.from_value", "modulename": "aspmc.semirings.probabilistic", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.is_idempotent", "modulename": "aspmc.semirings.probabilistic", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.one", "modulename": "aspmc.semirings.probabilistic", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.zero", "modulename": "aspmc.semirings.probabilistic", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.negate", "modulename": "aspmc.semirings.probabilistic", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "aspmc.semirings.probabilistic.to_string", "modulename": "aspmc.semirings.probabilistic", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat", "modulename": "aspmc.semirings.two_nat", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.semirings.two_nat.parse", "modulename": "aspmc.semirings.two_nat", "qualname": "parse", "type": "function", "doc": "<p></p>\n", "parameters": ["value", "atom"], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.from_value", "modulename": "aspmc.semirings.two_nat", "qualname": "from_value", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.negate", "modulename": "aspmc.semirings.two_nat", "qualname": "negate", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.to_string", "modulename": "aspmc.semirings.two_nat", "qualname": "to_string", "type": "function", "doc": "<p></p>\n", "parameters": ["value"], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.is_idempotent", "modulename": "aspmc.semirings.two_nat", "qualname": "is_idempotent", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.zero", "modulename": "aspmc.semirings.two_nat", "qualname": "zero", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.semirings.two_nat.one", "modulename": "aspmc.semirings.two_nat", "qualname": "one", "type": "function", "doc": "<p></p>\n", "parameters": [], "funcdef": "def"}, {"fullname": "aspmc.stats", "modulename": "aspmc.stats", "qualname": "", "type": "module", "doc": "<p>Main module providing the application logic.</p>\n"}, {"fullname": "aspmc.stats.Node", "modulename": "aspmc.stats", "qualname": "Node", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Node.__init__", "modulename": "aspmc.stats", "qualname": "Node.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "type", "name", "children", "ancestors"], "funcdef": "def"}, {"fullname": "aspmc.stats.Node.AND", "modulename": "aspmc.stats", "qualname": "Node.AND", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Node.OR", "modulename": "aspmc.stats", "qualname": "Node.OR", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Node.NEG", "modulename": "aspmc.stats", "qualname": "Node.NEG", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Node.IN", "modulename": "aspmc.stats", "qualname": "Node.IN", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Circuit", "modulename": "aspmc.stats", "qualname": "Circuit", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.stats.Circuit.__init__", "modulename": "aspmc.stats", "qualname": "Circuit.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "program", "deriv", "inputs"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.simp", "modulename": "aspmc.stats", "qualname": "Circuit.simp", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.no_holes", "modulename": "aspmc.stats", "qualname": "Circuit.no_holes", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.to_gr", "modulename": "aspmc.stats", "qualname": "Circuit.to_gr", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "stream"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.to_cnf", "modulename": "aspmc.stats", "qualname": "Circuit.to_cnf", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "stream"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.td_guided_to_cnf", "modulename": "aspmc.stats", "qualname": "Circuit.td_guided_to_cnf", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.td", "modulename": "aspmc.stats", "qualname": "Circuit.td", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "opt"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.tw", "modulename": "aspmc.stats", "qualname": "Circuit.tw", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "opt"], "funcdef": "def"}, {"fullname": "aspmc.stats.Circuit.to_dot", "modulename": "aspmc.stats", "qualname": "Circuit.to_dot", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "stream"], "funcdef": "def"}, {"fullname": "aspmc.stats.encoding_stats", "modulename": "aspmc.stats", "qualname": "encoding_stats", "type": "function", "doc": "<p></p>\n", "parameters": ["cnf"], "funcdef": "def"}, {"fullname": "aspmc.stats.main", "modulename": "aspmc.stats", "qualname": "main", "type": "function", "doc": "<p></p>\n", "parameters": ["cnf"], "funcdef": "def"}, {"fullname": "aspmc.util", "modulename": "aspmc.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.util.to_dimacs", "modulename": "aspmc.util", "qualname": "to_dimacs", "type": "function", "doc": "<p></p>\n", "parameters": ["var"], "funcdef": "def"}, {"fullname": "aspmc.util.to_pos", "modulename": "aspmc.util", "qualname": "to_pos", "type": "function", "doc": "<p></p>\n", "parameters": ["var"], "funcdef": "def"}, {"fullname": "aspmc.util.neg", "modulename": "aspmc.util", "qualname": "neg", "type": "function", "doc": "<p></p>\n", "parameters": ["var", "dimacs"], "funcdef": "def"}, {"fullname": "aspmc.wfParse", "modulename": "aspmc.wfParse", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "aspmc.wfParse.WeightedFormulaBuffer", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaBuffer", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.wfParse.WeightedFormulaBuffer.__init__", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaBuffer.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "text", "whitespace", "nameguard", "comments_re", "eol_comments_re", "ignorecase", "namechars", "kwargs"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaParser", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaParser", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.wfParse.WeightedFormulaParser.__init__", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaParser.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "whitespace", "nameguard", "comments_re", "eol_comments_re", "ignorecase", "left_recursion", "parseinfo", "keywords", "namechars", "tokenizercls", "kwargs"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics", "type": "class", "doc": "<p></p>\n"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.__init__", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "app"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.var2idx", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.var2idx", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "var"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.new_var", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.new_var", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.clause_writer", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.clause_writer", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "p", "c1", "c2", "connective"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.start", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.start", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.expression", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.expression", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.term", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.term", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.factor", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.factor", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.var", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.var", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}, {"fullname": "aspmc.wfParse.WeightedFormulaSemantics.number", "modulename": "aspmc.wfParse", "qualname": "WeightedFormulaSemantics.number", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "ast"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();